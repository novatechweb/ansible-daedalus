Bottom: 0a8d8dcce54102dfaafb5a67298bcb19c806b671
Top:    bb77ca6ac1b0b38651034f0c3e60fde2e68c7d75
Author: Andrew Cooper <andrew.cooper@novatechweb.com>
Date:   2018-08-29 16:44:42 -0500

Support asset host

---
diff --git a/ansible-playbook/buildbot.yml b/ansible-playbook/buildbot.yml
index 557ea2de..166390e6 100644
--- a/ansible-playbook/buildbot.yml
+++ b/ansible-playbook/buildbot.yml
@@ -9,6 +9,11 @@
     - buildbot
     - buildbot-master
   tasks:
+    - add_host:
+        name: nexus
+        groups: services
+        ip_addr: "{{ nexus_ip_addr }}"
+        uri: "http://{{nexus_hostname}}/repository"
     - name: Scan Gitlab ssh keys
       command: ssh-keyscan {{gitlab_hostname}}
       register: gitlab_keys
@@ -17,6 +22,7 @@
         name: buildbot-master
       vars:
         known_hosts: "{{gitlab_keys.stdout}}"
+        asset_host: "{{hostvars['nexus']['uri']}}"
     - name: Add buildbot user to Gitlab
       import_role:
         name: gitlab-user
@@ -37,7 +43,11 @@
     - buildbot-worker-ntel
     - buildbot-worker-ptxdist
   vars:
-    buildbot_master: "{{ hostvars['buildbot-master'].ip_addr }}"
+    asset_host: "{{hostvars['nexus']['uri']}}"
+    asset_user: "buildbot"
+    asset_password: "{{nexus_buildbot_password}}"
+    container_etc_hosts:
+      nexus.novatech-llc.com: "{{hostvars['nexus']['ip_addr']}}"
     known_hosts: "{{ gitlab_keys.stdout }}"
   tasks:
     - name: Scan Gitlab ssh keys
diff --git a/ansible-playbook/library/docker_image.py b/ansible-playbook/library/docker_image.py
new file mode 100644
index 00000000..90bf2b20
--- /dev/null
+++ b/ansible-playbook/library/docker_image.py
@@ -0,0 +1,615 @@
+#!/usr/bin/python
+#
+# Copyright 2016 Red Hat | Ansible
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+---
+module: docker_image
+
+short_description: Manage docker images.
+
+version_added: "1.5"
+
+description:
+     - Build, load or pull an image, making the image available for creating containers. Also supports tagging an
+       image into a repository and archiving an image to a .tar file.
+
+options:
+  archive_path:
+    description:
+      - Use with state C(present) to archive an image to a .tar file.
+    required: false
+    version_added: "2.1"
+  load_path:
+    description:
+      - Use with state C(present) to load an image from a .tar file.
+    required: false
+    version_added: "2.2"
+  dockerfile:
+    description:
+      - Use with state C(present) to provide an alternate name for the Dockerfile to use when building an image.
+    default: Dockerfile
+    required: false
+    version_added: "2.0"
+  force:
+    description:
+      - Use with state I(absent) to un-tag and remove all images matching the specified name. Use with state
+        C(present) to build, load or pull an image when the image already exists.
+    default: false
+    required: false
+    version_added: "2.1"
+    type: bool
+  http_timeout:
+    description:
+      - Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of
+        seconds.
+    required: false
+    version_added: "2.1"
+  name:
+    description:
+      - "Image name. Name format will be one of: name, repository/name, registry_server:port/name.
+        When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'."
+    required: true
+  path:
+    description:
+      - Use with state 'present' to build an image. Will be the path to a directory containing the context and
+        Dockerfile for building an image.
+    aliases:
+      - build_path
+    required: false
+  pull:
+    description:
+      - When building an image downloads any updates to the FROM image in Dockerfile.
+    default: true
+    required: false
+    version_added: "2.1"
+    type: bool
+  push:
+    description:
+      - Push the image to the registry. Specify the registry as part of the I(name) or I(repository) parameter.
+    default: false
+    required: false
+    version_added: "2.2"
+    type: bool
+  rm:
+    description:
+      - Remove intermediate containers after build.
+    default: true
+    required: false
+    version_added: "2.1"
+    type: bool
+  nocache:
+    description:
+      - Do not use cache when building an image.
+    default: false
+    required: false
+    type: bool
+  repository:
+    description:
+      - Full path to a repository. Use with state C(present) to tag the image into the repository. Expects
+        format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).
+    required: false
+    version_added: "2.1"
+  state:
+    description:
+      - Make assertions about the state of an image.
+      - When C(absent) an image will be removed. Use the force option to un-tag and remove all images
+        matching the provided name.
+      - When C(present) check if an image exists using the provided name and tag. If the image is not found or the
+        force option is used, the image will either be pulled, built or loaded. By default the image will be pulled
+        from Docker Hub. To build the image, provide a path value set to a directory containing a context and
+        Dockerfile. To load an image, specify load_path to provide a path to an archive file. To tag an image to a
+        repository, provide a repository path. If the name contains a repository path, it will be pushed.
+      - "NOTE: C(build) is DEPRECATED and will be removed in release 2.3. Specifying C(build) will behave the
+         same as C(present)."
+    required: false
+    default: present
+    choices:
+      - absent
+      - present
+      - build
+  tag:
+    description:
+      - Used to select an image when pulling. Will be added to the image when pushing, tagging or building. Defaults to
+        I(latest).
+      - If C(name) parameter format is I(name:tag), then tag value from C(name) will take precedence.
+    default: latest
+    required: false
+  buildargs:
+    description:
+      - Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.
+      - Docker expects the value to be a string. For convenience any non-string values will be converted to strings.
+      - Requires Docker API >= 1.21 and docker-py >= 1.7.0.
+    required: false
+    version_added: "2.2"
+  container_limits:
+    description:
+      - A dictionary of limits applied to each container created by the build process.
+    required: false
+    version_added: "2.1"
+    suboptions:
+      memory:
+        description:
+          - Set memory limit for build.
+      memswap:
+        description:
+          - Total memory (memory + swap), -1 to disable swap.
+      cpushares:
+        description:
+          - CPU shares (relative weight).
+      cpusetcpus:
+        description:
+          - CPUs in which to allow execution, e.g., "0-3", "0,1".
+  use_tls:
+    description:
+      - "DEPRECATED. Whether to use tls to connect to the docker server. Set to C(no) when TLS will not be used. Set to
+        C(encrypt) to use TLS. And set to C(verify) to use TLS and verify that the server's certificate is valid for the
+        server. NOTE: If you specify this option, it will set the value of the tls or tls_verify parameters."
+    choices:
+      - no
+      - encrypt
+      - verify
+    default: no
+    required: false
+    version_added: "2.0"
+  etc_hosts:
+    description:
+      - Dict of host-to-IP mappings, where each host name is a key in the dictionary.
+        Each host name will be added to the container's /etc/hosts file.
+    default: null
+    required: false
+
+extends_documentation_fragment:
+    - docker
+
+requirements:
+  - "python >= 2.6"
+  - "docker-py >= 1.7.0"
+  - "Docker API >= 1.20"
+
+author:
+  - Pavel Antonov (@softzilla)
+  - Chris Houseknecht (@chouseknecht)
+  - James Tanner (@jctanner)
+
+'''
+
+EXAMPLES = '''
+
+- name: pull an image
+  docker_image:
+    name: pacur/centos-7
+
+- name: Tag and push to docker hub
+  docker_image:
+    name: pacur/centos-7
+    repository: dcoppenhagan/myimage
+    tag: 7.0
+    push: yes
+
+- name: Tag and push to local registry
+  docker_image:
+     name: centos
+     repository: localhost:5000/centos
+     tag: 7
+     push: yes
+
+- name: Remove image
+  docker_image:
+    state: absent
+    name: registry.ansible.com/chouseknecht/sinatra
+    tag: v1
+
+- name: Build an image and push it to a private repo
+  docker_image:
+    path: ./sinatra
+    name: registry.ansible.com/chouseknecht/sinatra
+    tag: v1
+    push: yes
+
+- name: Archive image
+  docker_image:
+    name: registry.ansible.com/chouseknecht/sinatra
+    tag: v1
+    archive_path: my_sinatra.tar
+
+- name: Load image from archive and push to a private registry
+  docker_image:
+    name: localhost:5000/myimages/sinatra
+    tag: v1
+    push: yes
+    load_path: my_sinatra.tar
+
+- name: Build image and with buildargs
+  docker_image:
+     path: /path/to/build/dir
+     name: myimage
+     buildargs:
+       log_volume: /var/log/myapp
+       listen_port: 8080
+'''
+
+RETURN = '''
+image:
+    description: Image inspection results for the affected image.
+    returned: success
+    type: dict
+    sample: {}
+'''
+import os
+import re
+
+from ansible.module_utils.docker_common import HAS_DOCKER_PY_2, HAS_DOCKER_PY_3, AnsibleDockerClient, DockerBaseClass
+from ansible.module_utils._text import to_native
+
+try:
+    if HAS_DOCKER_PY_2 or HAS_DOCKER_PY_3:
+        from docker.auth import resolve_repository_name
+    else:
+        from docker.auth.auth import resolve_repository_name
+    from docker.utils.utils import parse_repository_tag
+except ImportError:
+    # missing docker-py handled in docker_common
+    pass
+
+
+class ImageManager(DockerBaseClass):
+
+    def __init__(self, client, results):
+
+        super(ImageManager, self).__init__()
+
+        self.client = client
+        self.results = results
+        parameters = self.client.module.params
+        self.check_mode = self.client.check_mode
+
+        self.archive_path = parameters.get('archive_path')
+        self.container_limits = parameters.get('container_limits')
+        self.dockerfile = parameters.get('dockerfile')
+        self.force = parameters.get('force')
+        self.load_path = parameters.get('load_path')
+        self.name = parameters.get('name')
+        self.nocache = parameters.get('nocache')
+        self.path = parameters.get('path')
+        self.pull = parameters.get('pull')
+        self.repository = parameters.get('repository')
+        self.rm = parameters.get('rm')
+        self.state = parameters.get('state')
+        self.tag = parameters.get('tag')
+        self.http_timeout = parameters.get('http_timeout')
+        self.push = parameters.get('push')
+        self.buildargs = parameters.get('buildargs')
+        self.etc_hosts = parameters.get('etc_hosts')
+
+        # If name contains a tag, it takes precedence over tag parameter.
+        repo, repo_tag = parse_repository_tag(self.name)
+        if repo_tag:
+            self.name = repo
+            self.tag = repo_tag
+
+        if self.state in ['present', 'build']:
+            self.present()
+        elif self.state == 'absent':
+            self.absent()
+
+    def fail(self, msg):
+        self.client.fail(msg)
+
+    def present(self):
+        '''
+        Handles state = 'present', which includes building, loading or pulling an image,
+        depending on user provided parameters.
+
+        :returns None
+        '''
+        image = self.client.find_image(name=self.name, tag=self.tag)
+
+        if not image or self.force:
+            if self.path:
+                # Build the image
+                if not os.path.isdir(self.path):
+                    self.fail("Requested build path %s could not be found or you do not have access." % self.path)
+                image_name = self.name
+                if self.tag:
+                    image_name = "%s:%s" % (self.name, self.tag)
+                self.log("Building image %s" % image_name)
+                self.results['actions'].append("Built image %s from %s" % (image_name, self.path))
+                self.results['changed'] = True
+                if not self.check_mode:
+                    self.results['image'] = self.build_image()
+            elif self.load_path:
+                # Load the image from an archive
+                if not os.path.isfile(self.load_path):
+                    self.fail("Error loading image %s. Specified path %s does not exist." % (self.name,
+                                                                                             self.load_path))
+                image_name = self.name
+                if self.tag:
+                    image_name = "%s:%s" % (self.name, self.tag)
+                self.results['actions'].append("Loaded image %s from %s" % (image_name, self.load_path))
+                self.results['changed'] = True
+                if not self.check_mode:
+                    self.results['image'] = self.load_image()
+            else:
+                # pull the image
+                self.results['actions'].append('Pulled image %s:%s' % (self.name, self.tag))
+                self.results['changed'] = True
+                if not self.check_mode:
+                    self.results['image'] = self.client.pull_image(self.name, tag=self.tag)
+                    if image and image == self.results['image']:
+                        self.results['changed'] = False
+
+        if self.archive_path:
+            self.archive_image(self.name, self.tag)
+
+        if self.push and not self.repository:
+            self.push_image(self.name, self.tag)
+        elif self.repository:
+            self.tag_image(self.name, self.tag, self.repository, force=self.force, push=self.push)
+
+    def absent(self):
+        '''
+        Handles state = 'absent', which removes an image.
+
+        :return None
+        '''
+        image = self.client.find_image(self.name, self.tag)
+        if image:
+            name = self.name
+            if self.tag:
+                name = "%s:%s" % (self.name, self.tag)
+            if not self.check_mode:
+                try:
+                    self.client.remove_image(name, force=self.force)
+                except Exception as exc:
+                    self.fail("Error removing image %s - %s" % (name, str(exc)))
+
+            self.results['changed'] = True
+            self.results['actions'].append("Removed image %s" % (name))
+            self.results['image']['state'] = 'Deleted'
+
+    def archive_image(self, name, tag):
+        '''
+        Archive an image to a .tar file. Called when archive_path is passed.
+
+        :param name - name of the image. Type: str
+        :return None
+        '''
+
+        if not tag:
+            tag = "latest"
+
+        image = self.client.find_image(name=name, tag=tag)
+        if not image:
+            self.log("archive image: image %s:%s not found" % (name, tag))
+            return
+
+        image_name = "%s:%s" % (name, tag)
+        self.results['actions'].append('Archived image %s to %s' % (image_name, self.archive_path))
+        self.results['changed'] = True
+        if not self.check_mode:
+            self.log("Getting archive of image %s" % image_name)
+            try:
+                image = self.client.get_image(image_name)
+            except Exception as exc:
+                self.fail("Error getting image %s - %s" % (image_name, str(exc)))
+
+            try:
+                with open(self.archive_path, 'w') as fd:
+                    if HAS_DOCKER_PY_3:
+                        for chunk in image:
+                            fd.write(chunk)
+                    else:
+                        for chunk in image.stream(2048, decode_content=False):
+                            fd.write(chunk)
+            except Exception as exc:
+                self.fail("Error writing image archive %s - %s" % (self.archive_path, str(exc)))
+
+        image = self.client.find_image(name=name, tag=tag)
+        if image:
+            self.results['image'] = image
+
+    def push_image(self, name, tag=None):
+        '''
+        If the name of the image contains a repository path, then push the image.
+
+        :param name Name of the image to push.
+        :param tag Use a specific tag.
+        :return: None
+        '''
+
+        repository = name
+        if not tag:
+            repository, tag = parse_repository_tag(name)
+        registry, repo_name = resolve_repository_name(repository)
+
+        self.log("push %s to %s/%s:%s" % (self.name, registry, repo_name, tag))
+
+        if registry:
+            self.results['actions'].append("Pushed image %s to %s/%s:%s" % (self.name, registry, repo_name, tag))
+            self.results['changed'] = True
+            if not self.check_mode:
+                status = None
+                try:
+                    for line in self.client.push(repository, tag=tag, stream=True, decode=True):
+                        self.log(line, pretty_print=True)
+                        if line.get('errorDetail'):
+                            raise Exception(line['errorDetail']['message'])
+                        status = line.get('status')
+                except Exception as exc:
+                    if re.search('unauthorized', str(exc)):
+                        if re.search('authentication required', str(exc)):
+                            self.fail("Error pushing image %s/%s:%s - %s. Try logging into %s first." %
+                                      (registry, repo_name, tag, str(exc), registry))
+                        else:
+                            self.fail("Error pushing image %s/%s:%s - %s. Does the repository exist?" %
+                                      (registry, repo_name, tag, str(exc)))
+                    self.fail("Error pushing image %s: %s" % (repository, str(exc)))
+                self.results['image'] = self.client.find_image(name=repository, tag=tag)
+                if not self.results['image']:
+                    self.results['image'] = dict()
+                self.results['image']['push_status'] = status
+
+    def tag_image(self, name, tag, repository, force=False, push=False):
+        '''
+        Tag an image into a repository.
+
+        :param name: name of the image. required.
+        :param tag: image tag.
+        :param repository: path to the repository. required.
+        :param force: bool. force tagging, even it image already exists with the repository path.
+        :param push: bool. push the image once it's tagged.
+        :return: None
+        '''
+        repo, repo_tag = parse_repository_tag(repository)
+        if not repo_tag:
+            repo_tag = "latest"
+            if tag:
+                repo_tag = tag
+        image = self.client.find_image(name=repo, tag=repo_tag)
+        found = 'found' if image else 'not found'
+        self.log("image %s was %s" % (repo, found))
+
+        if not image or force:
+            self.log("tagging %s:%s to %s:%s" % (name, tag, repo, repo_tag))
+            self.results['changed'] = True
+            self.results['actions'].append("Tagged image %s:%s to %s:%s" % (name, tag, repo, repo_tag))
+            if not self.check_mode:
+                try:
+                    # Finding the image does not always work, especially running a localhost registry. In those
+                    # cases, if we don't set force=True, it errors.
+                    image_name = name
+                    if tag and not re.search(tag, name):
+                        image_name = "%s:%s" % (name, tag)
+                    tag_status = self.client.tag(image_name, repo, tag=repo_tag, force=True)
+                    if not tag_status:
+                        raise Exception("Tag operation failed.")
+                except Exception as exc:
+                    self.fail("Error: failed to tag image - %s" % str(exc))
+                self.results['image'] = self.client.find_image(name=repo, tag=repo_tag)
+                if push:
+                    self.push_image(repo, repo_tag)
+
+    def build_image(self):
+        '''
+        Build an image
+
+        :return: image dict
+        '''
+        params = dict(
+            path=self.path,
+            tag=self.name,
+            rm=self.rm,
+            nocache=self.nocache,
+            timeout=self.http_timeout,
+            pull=self.pull,
+            forcerm=self.rm,
+            dockerfile=self.dockerfile,
+            decode=True
+        )
+        if not HAS_DOCKER_PY_3:
+            params['stream'] = True
+        build_output = []
+        if self.tag:
+            params['tag'] = "%s:%s" % (self.name, self.tag)
+        if self.container_limits:
+            params['container_limits'] = self.container_limits
+        if self.buildargs:
+            for key, value in self.buildargs.items():
+                self.buildargs[key] = to_native(value)
+            params['buildargs'] = self.buildargs
+
+        for line in self.client.build(**params):
+            # line = json.loads(line)
+            self.log(line, pretty_print=True)
+            if "stream" in line:
+                build_output.append(line["stream"])
+            if line.get('error'):
+                if line.get('errorDetail'):
+                    errorDetail = line.get('errorDetail')
+                    self.fail(
+                        "Error building %s - code: %s, message: %s, logs: %s" % (
+                            self.name,
+                            errorDetail.get('code'),
+                            errorDetail.get('message'),
+                            build_output))
+                else:
+                    self.fail("Error building %s - message: %s, logs: %s" % (
+                        self.name, line.get('error'), build_output))
+        return self.client.find_image(name=self.name, tag=self.tag)
+
+    def load_image(self):
+        '''
+        Load an image from a .tar archive
+
+        :return: image dict
+        '''
+        try:
+            self.log("Opening image %s" % self.load_path)
+            image_tar = open(self.load_path, 'r')
+        except Exception as exc:
+            self.fail("Error opening image %s - %s" % (self.load_path, str(exc)))
+
+        try:
+            self.log("Loading image from %s" % self.load_path)
+            self.client.load_image(image_tar)
+        except Exception as exc:
+            self.fail("Error loading image %s - %s" % (self.name, str(exc)))
+
+        try:
+            image_tar.close()
+        except Exception as exc:
+            self.fail("Error closing image %s - %s" % (self.name, str(exc)))
+
+        return self.client.find_image(self.name, self.tag)
+
+
+def main():
+    argument_spec = dict(
+        archive_path=dict(type='path'),
+        container_limits=dict(type='dict'),
+        dockerfile=dict(type='str'),
+        force=dict(type='bool', default=False),
+        http_timeout=dict(type='int'),
+        load_path=dict(type='path'),
+        name=dict(type='str', required=True),
+        nocache=dict(type='bool', default=False),
+        path=dict(type='path', aliases=['build_path']),
+        pull=dict(type='bool', default=True),
+        push=dict(type='bool', default=False),
+        repository=dict(type='str'),
+        rm=dict(type='bool', default=True),
+        state=dict(type='str', choices=['absent', 'present', 'build'], default='present'),
+        tag=dict(type='str', default='latest'),
+        use_tls=dict(type='str', default='no', choices=['no', 'encrypt', 'verify']),
+        buildargs=dict(type='dict', default=None),
+        etc_hosts=dict(type='dict'),
+    )
+
+    client = AnsibleDockerClient(
+        argument_spec=argument_spec,
+        supports_check_mode=True,
+    )
+
+    results = dict(
+        changed=False,
+        actions=[],
+        image={}
+    )
+
+    ImageManager(client, results)
+    client.module.exit_json(**results)
+
+
+if __name__ == '__main__':
+    main()
diff --git a/docker/buildbot-worker-ntel/Dockerfile b/docker/buildbot-worker-ntel/Dockerfile
index 729332d4..5d040ea8 100644
--- a/docker/buildbot-worker-ntel/Dockerfile
+++ b/docker/buildbot-worker-ntel/Dockerfile
@@ -68,8 +68,9 @@ RUN wget https://bootstrap.pypa.io/get-pip.py \
 
 # Install software for image signing
 ARG PTK_HSM_HOST="127.0.0.1"
+ARG PTK_URI="http://127.0.0.1/610-009981-015_SW_PTK_5.3_Client_RevA.tar"
 
-RUN curl http://172.16.64.2/~georgem/610-009981-015_SW_PTK_5.3_Client_RevA.tar \
+RUN curl ${PTK_URI} \
 |   tar -v -x -C /tmp \
 &&  alien --to-deb --install --scripts /tmp/610-009981-015_SW_PTK_5.3_Client_RevA/SDKs/Linux64/ptkc_sdk/PTKcpsdk-5.3.0-16.x86_64.rpm \
 &&  alien --to-deb --install --scripts /tmp/610-009981-015_SW_PTK_5.3_Client_RevA/SDKs/Linux64/ptkc_runtime/PTKcprt-5.3.0-15.x86_64.rpm \
diff --git a/docker/buildbot-worker-ptxdist/buildbot/.ptxdist/ptxdistrc-git b/docker/buildbot-worker-ptxdist/buildbot/.ptxdist/ptxdistrc-git
index 7dbac6ef..b5c0c70e 100644
--- a/docker/buildbot-worker-ptxdist/buildbot/.ptxdist/ptxdistrc-git
+++ b/docker/buildbot-worker-ptxdist/buildbot/.ptxdist/ptxdistrc-git
@@ -36,12 +36,12 @@ PTXCONF_SETUP_SRCDIR="/cache/downloads"
 #
 # PTXCONF_SETUP_NO_DOWNLOAD is not set
 # PTXCONF_SETUP_PTXMIRROR_ONLY is not set
-PTXCONF_SETUP_PTXMIRROR="http://www.pengutronix.de/software/ptxdist/temporary-src"
-PTXCONF_SETUP_DEBMIRROR="http://ftp.uni-kl.de/debian"
-PTXCONF_SETUP_SFMIRROR="http://downloads.sourceforge.net/sourceforge"
-PTXCONF_SETUP_GNUMIRROR="http://ftp.uni-kl.de/pub/gnu"
-PTXCONF_SETUP_XORGMIRROR="http://xorg.mirrors.pair.com/pub/X11/ftp.x.org"
-PTXCONF_SETUP_KERNELMIRROR="http://www.kernel.org/pub/linux"
+PTXCONF_SETUP_PTXMIRROR="http://nexus.novatech-llc.com/repository/orphans"
+PTXCONF_SETUP_DEBMIRROR="http://nexus.novatech-llc.com/repository/debian"
+PTXCONF_SETUP_SFMIRROR="http://nexus.novatech-llc.com/repository/sourceforge"
+PTXCONF_SETUP_GNUMIRROR="http://nexus.novatech-llc.com/repository/gnu"
+PTXCONF_SETUP_XORGMIRROR="http://nexus.novatech-llc.com/repository/xorg"
+PTXCONF_SETUP_KERNELMIRROR="http://nexus.novatech-llc.com/repository/kernel"
 # PTXCONF_SETUP_CHECK_ALWAYS is not set
 PTXCONF_SETUP_CHECK_NOTEMPTY=y
 # PTXCONF_SETUP_CHECK_NEVER is not set
diff --git a/docker/buildbot-worker-ptxdist/buildbot/.pydistutils.cfg b/docker/buildbot-worker-ptxdist/buildbot/.pydistutils.cfg
deleted file mode 100644
index 8dc2a29b..00000000
--- a/docker/buildbot-worker-ptxdist/buildbot/.pydistutils.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-[easy_install]
-index-url=http://172.16.103.72/repository/PyPi_Proxy/simple
diff --git a/roles/buildbot-master/defaults/main.yml b/roles/buildbot-master/defaults/main.yml
index 3e81b9b2..ee40c325 100644
--- a/roles/buildbot-master/defaults/main.yml
+++ b/roles/buildbot-master/defaults/main.yml
@@ -32,6 +32,7 @@ config_hostdir: '{{ docker_restore_config_base_dir }}/{{ container_name }}'
 
 # environment passed to the container
 container_env:
+  ASSET_HOST: '{{asset_host}}'
   BUILDBOT_DATABASE: 'sqlite:///{{ data_path }}/state.sqlite'
   BUILDBOT_KNOWN_HOSTS_FILE: '{{secrets_path}}/{{secrets_known_hosts}}'
   BUILDBOT_SMTP_HOST: 'relay.dnsexit.com'
diff --git a/roles/buildbot-master/files/openembedded.py b/roles/buildbot-master/files/openembedded.py
index 5c2d9da5..89c57a2c 100755
--- a/roles/buildbot-master/files/openembedded.py
+++ b/roles/buildbot-master/files/openembedded.py
@@ -66,13 +66,20 @@ c['schedulers'] = [
             util.BooleanParameter(
                 name="clobber",
                 label="Clobber build directory",
-                default=False
-            ),
+                default=False),
             util.BooleanParameter(
                 name='cache',
                 label="Use cached state",
-                default=True
-            ),
+                default=True),
+            util.StringParameter(
+                name="release_pin",
+                label="PIN for release signing",
+                default='',
+                required=False),
+            util.StringParameter(
+                name='bbflags',
+                label="BitBake Options",
+                default=DEFAULT_BBFLAGS),
             util.StringParameter(
                 name="release_pin",
                 label="PIN for release signing",
@@ -140,6 +147,17 @@ def ComputeBuildProperties(props):
     newprops['timestamp'] = CurrentTime()
 
     version = props.getProperty('version', default=newprops['timestamp'])
+
+    urlpath = 'ntel/unofficial'
+
+    if props.getProperty('release_pin') is True:
+        urlpath = 'ntel/release'
+
+    if props.getProperty('scheduler') == 'ntel-nightly':
+        urlpath = 'ntel/nightly'
+
+    urlpath = os.path.join('ntel', urlpath, version)
+
     newprops['artifacts'] = {}
     machines = [props.getProperty('machine')]
 
@@ -253,9 +271,9 @@ class BitBakeArchive(steps.ShellSequence):
             'description': 'archiving',
             'descriptionDone': 'archive',
             'env': {
-                    'ENV': 'environment-ntel',
-                    'BASH_ENV': 'environment-ntel',
-                    },
+                'ENV': 'environment-ntel',
+                'BASH_ENV': 'environment-ntel',
+            },
             'flunkOnFailure': True,
             'haltOnFailure': False,
             'name': 'archive',
@@ -283,6 +301,18 @@ class BitBakeArchive(steps.ShellSequence):
                 ],
                 logfile="Create %s archive" % (m),
             ))
+
+            arturl = art['url']
+            commands.append(util.ShellArg(
+                logfile="Upload %s archive" % (m),
+                haltOnFailure=False,
+                flunkOnFailure=True,
+                command=[
+                    'curl', '--netrc', '--verbose',
+                    '--upload-file', artfile,
+                    '--url', arturl
+                ],
+            ))
         return steps.ShellSequence.runShellSequence(self, commands)
 
 
diff --git a/roles/buildbot-master/files/ptxdist.py b/roles/buildbot-master/files/ptxdist.py
index c6e148cf..c6e563b8 100644
--- a/roles/buildbot-master/files/ptxdist.py
+++ b/roles/buildbot-master/files/ptxdist.py
@@ -194,6 +194,16 @@ class PTXDistBuild(steps.ShellSequence):
                     "-f", util.Interpolate("%(prop:artifact_dest)s/%(prop:ipkg_artifact)s"),
                     util.Property("project")
                 ]),
+
+            util.ShellArg(
+                logfile="upload",
+                haltOnFailure=False,
+                flunkOnFailure=True,
+                command=[
+                    'curl', '--netrc', '--verbose',
+                    '--upload-file', util.Property('ipkg_artifact'),
+                    '--url', util.Property('ipkg_url')
+                ]),
         ]
 
 
@@ -220,8 +230,10 @@ class PTXDistImages(steps.ShellSequence):
             util.ShellArg(
                 logfile="ptxdist images",
                 haltOnFailure=True,
-                command=["ptxdist", "images"],
-            ),
+                command=[
+                    "ptxdist",
+                    "images"
+                ]),
 
             util.ShellArg(
                 logfile="archive",
@@ -231,8 +243,17 @@ class PTXDistImages(steps.ShellSequence):
                     "-C", util.Property("image_root"),
                     "-f", util.Interpolate("%(prop:artifact_dest)s/%(prop:image_artifact)s"),
                     "."
-                ]
-            ),
+                ]),
+
+            util.ShellArg(
+                logfile="upload",
+                haltOnFailure=False,
+                flunkOnFailure=True,
+                command=[
+                    'curl', '--netrc', '--verbose',
+                    '--upload-file', util.Property('image_artifact'),
+                    '--url', util.Property('image_url')
+                ]),
         ]
 
 
@@ -287,6 +308,37 @@ def ComputeBuildProperties(props):
         props.getProperty('platform')
     )
 
+    if props.getProperty('release'):
+        urlpath = os.path.join(
+            'ptxdist',
+            'release',
+            version
+        )
+    elif props.getProperty('scheduler') == "ptxdist-nightly":
+        urlpath = os.path.join(
+            'ptxdist',
+            'nightly',
+            version
+        )
+    else:
+        urlpath = os.path.join(
+            'ptxdist',
+            'beta',
+            version
+        )
+
+    newprops['ipkg_url'] = os.path.join(
+        ASSET_HOST,
+        urlpath,
+        ipkg_artifact,
+    )
+
+    newprops['image_url'] = os.path.join(
+        ASSET_HOST,
+        urlpath,
+        image_artifact,
+    )
+
     return newprops
 
 
diff --git a/roles/buildbot-worker-ntel/defaults/main.yml b/roles/buildbot-worker-ntel/defaults/main.yml
index f1bd9b16..0f440dc6 100644
--- a/roles/buildbot-worker-ntel/defaults/main.yml
+++ b/roles/buildbot-worker-ntel/defaults/main.yml
@@ -27,12 +27,16 @@ cache_volume: '{{ docker_name_prefix }}{{ container_hostname }}-cache'
 
 # environment passed to the container
 container_env:
+  ASSET_HOST: '{{asset_host}}/ntel'
   BUILDBOT_KNOWN_HOSTS_FILE: '{{secrets_path}}/{{secrets_known_hosts}}'
   BUILDBOT_MASTER: '{{ buildbot_master }}'
   BUILDBOT_WORKER_PORT: '{{ buildbot_worker_port }}'
   BUILDBOT_WORKER_NAME: 'worker-ntel'
   BUILDBOT_WORKER_PASS: 'pass'
 
+# extra hosts to add to container's /etc/hosts file
+container_etc_hosts: []
+
 # container_hostname
 container_hostname: '{{ role_name }}'
 
@@ -50,6 +54,9 @@ container_volumes:
 - '{{ data_volume }}:{{ data_path }}:z'
 - '{{ cache_volume }}:{{ cache_path }}:z'
 - '{{ secrets_hostdir }}:{{ secrets_path }}'
+- '{{ config_hostdir }}/pydistutils.cfg:/home/buildbot/.pydistutils.cfg'
+- '{{ config_hostdir }}/ptxdistrc:/home/buildbot/.ptxdist/ptxdistrc-2012.09'
+- '{{ config_hostdir }}/netrc:/home/buildbot/.netrc'
 
 # mount path of the data volume
 data_path: '/buildbot'
@@ -64,7 +71,7 @@ hsm_host: '{{ansible_facts.default_ipv4.address}}'
 image_args:
   BUILDBOT_UID: '{{buildbot_uid}}'
   BUILDBOT_VERSION: 'v{{buildbot_version}}'
-  PTK_URI: '{{asset_host}}/610-009981-015_SW_PTK_5.3_Client_RevA.tar'
+  PTK_URI: '{{asset_host}}/download/610-009981-015_SW_PTK_5.3_Client_RevA.tar'
   PTK_HSM_HOST: '{{hsm_host}}'
 
 # directory of the image source
diff --git a/roles/buildbot-worker-ntel/tasks/main.yml b/roles/buildbot-worker-ntel/tasks/main.yml
index b1bcf349..c6c57101 100644
--- a/roles/buildbot-worker-ntel/tasks/main.yml
+++ b/roles/buildbot-worker-ntel/tasks/main.yml
@@ -25,7 +25,7 @@
     - '{{ cache_volume }}:{{ cache_path }}:z'
     detach: no
     cleanup: yes
-    command: /bin/ash -c 
+    command: /bin/ash -c
       "mkdir -p {{item}} &&
       chown -c -R {{buildbot_uid}}:{{buildbot_uid}} {{item}} &&
       chmod -v 777 {{item}}"
@@ -44,12 +44,32 @@
     - '{{ data_volume }}:{{ data_path }}:z'
     detach: no
     cleanup: yes
-    command: /bin/ash -c 
+    command: /bin/ash -c
       "mkdir -p {{item}} &&
       if [ $(stat --printf='%u' '{{item}}') -ne {{buildbot_uid}} ]; then
         chown -c -R {{buildbot_uid}}:{{buildbot_uid}} {{item}};
       fi"
 
+- name: Create configuration directory
+  file:
+    path: '{{ config_hostdir }}'
+    state: directory
+
+- name: Generate distutils configuration
+  template:
+    src: pydistutils.cfg.j2
+    dest: '{{ config_hostdir }}/pydistutils.cfg'
+    group: '{{ buildbot_uid }}'
+    owner: '{{ buildbot_uid }}'
+
+- name: Populate assets secret
+  template:
+    src: "netrc.j2"
+    dest: '{{ config_hostdir }}/netrc'
+    group: '{{ buildbot_uid }}'
+    owner: '{{ buildbot_uid }}'
+    mode: "u=rw,g=,o="
+
 - name: Create secrets volume
   file:
     path: '{{ secrets_hostdir }}'
@@ -65,6 +85,7 @@
     repo: '{{ image_repo }}'
     version: master
     dest: '{{ image_dir }}'
+    force: yes
 
 - name: Create buildbot worker image
   docker_image:
@@ -72,10 +93,12 @@
     tag: '{{ docker_image_tag }}'
     path: '{{ image_dir }}'
     buildargs: '{{ image_args }}'
+    extra_hosts: '{{ container_etc_hosts }}'
     force: true
 
 - name: Start buildbot worker container
   docker_container:
+    etc_hosts: '{{ container_etc_hosts }}'
     hostname: '{{ container_hostname }}'
     name: '{{ container_name }}'
     image: '{{ image_name }}:{{ docker_image_tag }}'
diff --git a/roles/buildbot-worker-ntel/templates/netrc.j2 b/roles/buildbot-worker-ntel/templates/netrc.j2
new file mode 100644
index 00000000..e81d1062
--- /dev/null
+++ b/roles/buildbot-worker-ntel/templates/netrc.j2
@@ -0,0 +1,3 @@
+machine {{ asset_host | urlsplit('hostname') }}
+login {{ asset_user }}
+password {{ asset_password }}
diff --git a/roles/buildbot-worker-ntel/templates/ptxdistrc.j2 b/roles/buildbot-worker-ntel/templates/ptxdistrc.j2
new file mode 100644
index 00000000..4d2b48e9
--- /dev/null
+++ b/roles/buildbot-worker-ntel/templates/ptxdistrc.j2
@@ -0,0 +1,76 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# PTXdist 2012.09.1-00373-gee9622f
+#
+
+#
+# PTXDIST Setup Menu
+#
+
+#
+# User
+#
+PTXCONF_SETUP_USER_NAME="NovaTech Buildbot"
+PTXCONF_SETUP_USER_EMAIL="buildbot@novatechweb.com"
+
+#
+# Proxies
+#
+PTXCONF_SETUP_FTP_PROXY=""
+PTXCONF_SETUP_HTTP_PROXY=""
+PTXCONF_SETUP_HTTPS_PROXY=""
+PTXCONF_SETUP_NO_PROXY=""
+
+#
+# Project Searchpath
+#
+PTXCONF_SETUP_PROJECTPATH="${PTXDIST_TOPDIR}/projects"
+
+#
+# Source Directories
+#
+PTXCONF_SETUP_SRCDIR="{{cache_path}}/downloads"
+
+#
+# Source Download
+#
+# PTXCONF_SETUP_NO_DOWNLOAD is not set
+# PTXCONF_SETUP_PTXMIRROR_ONLY is not set
+PTXCONF_SETUP_PTXMIRROR="{{asset_host}}/orphans"
+PTXCONF_SETUP_DEBMIRROR="{{asset_host}}/debian"
+PTXCONF_SETUP_SFMIRROR="{{asset_host}}/sourceforge"
+PTXCONF_SETUP_GNUMIRROR="{{asset_host}}/gnu"
+PTXCONF_SETUP_XORGMIRROR="{{asset_host}}/xorg"
+PTXCONF_SETUP_KERNELMIRROR="{{asset_host}}/kernel"
+PTXCONF_SETUP_PYPIMIRROR="{{asset_host}}/pypi"
+# PTXCONF_SETUP_CHECK_ALWAYS is not set
+PTXCONF_SETUP_CHECK_NOTEMPTY=y
+# PTXCONF_SETUP_CHECK_NEVER is not set
+PTXCONF_SETUP_CHECK="notempty"
+
+#
+# IPKG Repository
+#
+PTXCONF_SETUP_IPKG_REPOSITORY="{{cache_path}}/ipkg-repository"
+
+#
+# Java SDK
+#
+PTXCONF_SETUP_JAVA_SDK="/usr"
+
+#
+# Developer Options
+#
+# PTXCONF_SETUP_DISABLE_LOCAL_CHECK is not set
+PTXCONF_SETUP_ENV_WHITELIST=""
+# PTXCONF_SETUP_COMMON_CACHE is not set
+# PTXCONF_SETUP_GEN_DEP_TREE is not set
+# PTXCONF_SETUP_CHECK_EXIT_ON_ERROR is not set
+PTXCONF_SETUP_CCACHE=y
+PTXCONF_SETUP_PATCHIN_GIT=y
+# PTXCONF_SETUP_NFS_REL_SYMLINK is not set
+# PTXCONF_SETUP_DIRECT_CLEAN is not set
+PTXCONF_SETUP_HOST_CPP="cpp"
+PTXCONF_SETUP_HOST_CC="gcc"
+PTXCONF_SETUP_HOST_CXX="g++"
+PTXCONF_SETUP_HOST_MAKE="make"
diff --git a/roles/buildbot-worker-ntel/templates/pydistutils.cfg.j2 b/roles/buildbot-worker-ntel/templates/pydistutils.cfg.j2
new file mode 100644
index 00000000..1d205ea2
--- /dev/null
+++ b/roles/buildbot-worker-ntel/templates/pydistutils.cfg.j2
@@ -0,0 +1,2 @@
+[easy_install]
+index_url = {{asset_host}}/pypi/simple
diff --git a/roles/buildbot-worker-ptxdist/defaults/main.yml b/roles/buildbot-worker-ptxdist/defaults/main.yml
index ebe2d7ed..5a128da1 100644
--- a/roles/buildbot-worker-ptxdist/defaults/main.yml
+++ b/roles/buildbot-worker-ptxdist/defaults/main.yml
@@ -27,6 +27,7 @@ cache_volume: '{{ docker_name_prefix }}{{ container_hostname }}-cache'
 
 # environment passed to the container
 container_env:
+  ASSET_HOST: '{{asset_host}}/ptxdist'
   BUILDBOT_KNOWN_HOSTS_FILE: '{{secrets_path}}/{{secrets_known_hosts}}'
   BUILDBOT_MASTER: '{{ buildbot_master }}'
   BUILDBOT_WORKER_PORT: '{{ buildbot_worker_port }}'
@@ -42,6 +43,9 @@ container_name: '{{ docker_name_prefix }}{{ container_hostname }}'
 # network configuration for the confainer
 container_networks: []
 
+# network configuration for the confainer
+container_networks: []
+
 # port configuration of the container
 container_port_args: []
 
diff --git a/roles/buildbot-worker-ptxdist/tasks/main.yml b/roles/buildbot-worker-ptxdist/tasks/main.yml
index ce3e4e97..46bf6355 100644
--- a/roles/buildbot-worker-ptxdist/tasks/main.yml
+++ b/roles/buildbot-worker-ptxdist/tasks/main.yml
@@ -104,10 +104,12 @@
     tag: '{{ docker_image_tag }}'
     path: '{{ image_dir }}'
     buildargs: '{{ image_args }}'
+    extra_hosts: '{{ container_etc_hosts }}'
     force: true
 
 - name: Start buildbot worker container
   docker_container:
+    etc_hosts: '{{ container_etc_hosts }}'
     hostname: '{{ container_hostname }}'
     name: '{{ container_name }}'
     image: '{{ image_name }}:{{ docker_image_tag }}'
diff --git a/roles/buildbot-worker-ptxdist/templates/pydistutils.cfg.j2 b/roles/buildbot-worker-ptxdist/templates/pydistutils.cfg.j2
new file mode 100644
index 00000000..1d205ea2
--- /dev/null
+++ b/roles/buildbot-worker-ptxdist/templates/pydistutils.cfg.j2
@@ -0,0 +1,2 @@
+[easy_install]
+index_url = {{asset_host}}/pypi/simple
