From 4e9909563915e3d9c54561bfc6a62415c3606957 Mon Sep 17 00:00:00 2001
From: George McCollister <George.McCollister@gmail.com>
Date: Tue, 27 Mar 2012 11:17:07 -0500
Subject: [PATCH] account for unopen file space during upgrade

If a file belonging to a package is open by a process when that package
is upgraded the space will not be reclaimed until the file is closed.
However, if a file belonging to a package isn't open by any processes
the space will be reclaimed immediately and can count towards the available
free disk space.

Signed-off-by: George McCollister <George.McCollister@gmail.com>
---
 libopkg/opkg_install.c |  255 +++++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 251 insertions(+), 4 deletions(-)

diff --git a/libopkg/opkg_install.c b/libopkg/opkg_install.c
index 74a2ce1..719518f 100644
--- a/libopkg/opkg_install.c
+++ b/libopkg/opkg_install.c
@@ -18,10 +18,13 @@
 #include "config.h"
 
 #include <stdio.h>
+#include <stddef.h>
 #include <time.h>
 #include <signal.h>
 #include <unistd.h>
 #include <sys/stat.h>
+#include <dirent.h>
+#include <ctype.h>
 
 #include "pkg.h"
 #include "pkg_hash.h"
@@ -189,16 +192,258 @@ update_file_ownership(pkg_t *new_pkg, pkg_t *old_pkg)
      return 0;
 }
 
+size_t 
+dirent_buf_size(DIR * dirp)
+{
+    long name_max;
+    size_t name_end;
+#if defined(HAVE_FPATHCONF) && defined(HAVE_DIRFD) \
+       && defined(_PC_NAME_MAX)
+        name_max = fpathconf(dirfd(dirp), _PC_NAME_MAX);
+        if (name_max == -1)
+#           if defined(NAME_MAX)
+                name_max = (NAME_MAX > 255) ? NAME_MAX : 255;
+#           else
+                return (size_t)(-1);
+#           endif
+#   else
+#       if defined(NAME_MAX)
+            name_max = (NAME_MAX > 255) ? NAME_MAX : 255;
+#       else
+#           error "buffer size for readdir_r cannot be determined"
+#       endif
+#   endif
+    name_end = (size_t)offsetof(struct dirent, d_name) + name_max + 1;
+    return (name_end > sizeof(struct dirent)
+            ? name_end : sizeof(struct dirent));
+}
+
+int 
+process_file(const char * cstrFile, size_t size, str_list_t *subtract_files)
+{
+	char * strFile = (char*) malloc(size+1);
+	if( !strFile )
+		return -1;
+	memcpy(strFile, cstrFile, size);
+	strFile[size] = '\0';
+	//printf("\t%s\n", strFile);	
+	str_list_remove_elt(subtract_files, strFile);
+	free(strFile);
+	return 0;
+}
+
+int 
+process_maps(const char * strPID, str_list_t *subtract_files) {
+	const char deleted[]=" (deleted)\n";
+	char strFilePath[64];
+	FILE * pin;
+	char * strLine = NULL;
+	size_t buflen = 0;
+	int deleted_len = strlen(deleted);
+	
+	//Read maps
+	snprintf(strFilePath, sizeof(strFilePath)-1, "/proc/%s/maps", strPID);
+	pin = fopen(strFilePath, "rb");
+	if( !pin ) {
+		perror("fopen");
+		return 1;
+	}
+	
+	while(getline(&strLine, &buflen, pin) != -1 && strLine) {
+		char * pSearch = strLine;
+		while(*pSearch != '\0') {
+			if(*pSearch == '/') {
+				int ideleted = 0;
+				int ilen = strlen(pSearch);
+				if( ilen > deleted_len ) {
+					if(strcmp(pSearch + ilen - deleted_len, deleted) == 0)
+					{
+						//printf("\t\tdeleted file\n");
+						ideleted = 1;
+					}
+				}
+				
+				if(ideleted)
+					process_file(
+						pSearch, 
+						ilen - deleted_len, 
+						subtract_files);
+				else
+					process_file(
+						pSearch, 
+						ilen - 1, 
+						subtract_files);
+				break;
+			}
+			pSearch++;
+		}
+	}
+	if(strLine)
+		free(strLine);
+	
+	fclose(pin);
+	return 0;
+}
+
+#define FILENAME_BUF_SIZE 1024
+
+int 
+process_fds(const char * strPID, str_list_t *subtract_files) {
+	//Read fd directory
+	
+	char strFilePath[64];
+	char * pFilename;
+	DIR * pdir;
+	struct dirent * pdirent, * pbuf;
+	size_t size;
+	ssize_t ssize;
+	struct stat statbuf;
+	
+	int error;
+	int result = 0;
+	
+	snprintf(strFilePath, sizeof(strFilePath)-1, "/proc/%s/fd", strPID);
+	
+	pdir = opendir(strFilePath);
+	
+	if(!pdir) {
+		perror("opendir");
+		return 1;
+	}
+	
+	size = dirent_buf_size(pdir);
+	if (size == -1) {
+		perror("dirent_buf_size");
+		return 1;
+	}
+	
+	pbuf = (struct dirent *)malloc(size);
+	if( !pbuf ) {
+		perror("malloc");
+		return 1;
+	}
+	
+	pFilename = (char *)malloc(FILENAME_BUF_SIZE);
+	if( !pFilename ) {
+		perror("malloc");
+		return 1;
+	}
+	
+	while( (error = readdir_r(pdir, pbuf, &pdirent)) == 0 && pdirent != NULL) {
+		snprintf(strFilePath, sizeof(strFilePath)-1, "/proc/%s/fd/%s", strPID, pdirent->d_name);
+		if( lstat(strFilePath, &statbuf) != 0 )
+		{
+			perror("lstat");
+			result = 1;
+			break;
+		}
+		if( S_ISLNK(statbuf.st_mode) )
+		{
+			ssize = readlink(strFilePath, pFilename, FILENAME_BUF_SIZE);
+			if( ssize > 0 && pFilename[0] == '/') {
+				process_file(pFilename, (size_t)ssize, subtract_files);
+			}
+		}
+	}
+	closedir(pdir);
+	free(pbuf);
+	free(pFilename);
+	return result;
+}
+
+static int
+process_pid(const char * strPID, str_list_t *subtract_files) {
+	int result = process_maps(strPID, subtract_files);
+	if( result != 0 )
+		return result;
+	return process_fds(strPID, subtract_files);
+}
+
 static int
-verify_pkg_installable(pkg_t *pkg)
+verify_pkg_installable(pkg_t *pkg, pkg_t *old_pkg)
 {
-	unsigned long kbs_available, pkg_size_kbs;
+	unsigned long kbs_available, pkg_size_kbs, unheld_kbs, unheld_bytes = 0;
 	char *root_dir = NULL;
 	struct stat s;
 
 	if (conf->force_space || pkg->installed_size == 0)
 		return 0;
 
+	//If an old version of the package is installed
+	//figure out which of its files are open
+	//and add the size of the unopen files to the
+	//disk free space.
+	if( old_pkg ) {
+		str_list_t *installed_files;
+		str_list_t *subtract_files;
+		DIR * pdir;
+		struct dirent * pdirent, * pbuf;
+		size_t size;
+		int error;		
+		str_list_elt_t *iter, *niter;
+		installed_files = pkg_get_installed_files(old_pkg); /* this causes installed_files to be cached */
+		
+		if (installed_files == NULL) {
+			opkg_msg(ERROR, "Failed to determine installed "
+				"files for pkg %s.\n", old_pkg->name);
+			return -1;
+		}
+		subtract_files = str_list_alloc();
+		for (iter = str_list_first(installed_files), niter = str_list_next(installed_files, iter);
+			iter;
+			iter = niter, niter = str_list_next(installed_files, iter)) {
+			opkg_msg(DEBUG2, "old files: %s\n", (char *) iter->data);
+			str_list_append(subtract_files, (char *) iter->data);
+		}
+		pkg_free_installed_files(old_pkg);
+
+		pdir = opendir("/proc");
+		if(!pdir) {
+			opkg_msg(ERROR, "opendir failed with errno: %d", errno);
+			return -1;
+		}
+		
+		size = dirent_buf_size(pdir);
+		if (size == -1) {
+			opkg_msg(ERROR, "dirent_buf_size failed");
+			return -1;
+		}
+		
+		pbuf = (struct dirent *)malloc(size);
+		if( !pbuf ) {
+			opkg_msg(ERROR, "malloc failed with errno: %d", errno);
+			return -1;
+		}
+	
+		while( (error = readdir_r(pdir, pbuf, &pdirent)) == 0 && pdirent != NULL) {
+			int is_pid = 1;
+			int i;
+			for(i=0; i<strlen(pdirent->d_name); i++) {
+				if( !isdigit(pdirent->d_name[i]) ) {
+					is_pid = 0;
+					break;
+				}
+			}
+			
+			if(is_pid) {
+				//printf("%s\n", pdirent->d_name);
+				process_pid(pdirent->d_name, subtract_files);
+			}
+		}
+		closedir(pdir);
+		free(pbuf);
+		for (iter = str_list_first(subtract_files), niter = str_list_next(subtract_files, iter);
+			iter;
+			iter = niter, niter = str_list_next(subtract_files, iter)) {
+			opkg_msg(DEBUG2, "subtract files: %s\n", (char *) iter->data);
+			if( !lstat((char *) iter->data, &s) ) {
+				unheld_bytes += (unsigned long) s.st_size;
+			}
+		}
+		str_list_purge(subtract_files);
+		opkg_msg(DEBUG2, "unheld_bytes: %lu\n", unheld_bytes);
+	}
+
 	if (pkg->dest)
 	{
 		if (!strcmp(pkg->dest->name, "root") && conf->overlay_root
@@ -211,7 +456,9 @@ verify_pkg_installable(pkg_t *pkg)
 	if (!root_dir)
 		root_dir = conf->default_dest->root_dir;
 
-	kbs_available = get_available_kbytes(root_dir);
+	unheld_kbs = (unheld_bytes + 1023)/1024;
+
+	kbs_available = get_available_kbytes(root_dir) + unheld_kbs;
 
 	pkg_size_kbs = (pkg->installed_size + 1023)/1024;
 
@@ -1258,7 +1505,7 @@ opkg_install_pkg(pkg_t *pkg, int from_upgrade)
      if (pkg->state_status == SS_INSTALLED)
 	     return 0;
 
-     err = verify_pkg_installable(pkg);
+     err = verify_pkg_installable(pkg, old_pkg);
      if (err)
 	     return -1;
 
-- 
1.7.1

